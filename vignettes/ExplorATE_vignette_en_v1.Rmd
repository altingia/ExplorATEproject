---
title: "ExplorATE - Explore Active Transposable Elements -"
author: "Martin M. Femenias"
output:
  html_document:
    df_print: paged
  pdf_document: default
vignette: |
  %\VignetteIndexEntry{ExplorATE vignette} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---
ExplorATE (Explore Active Transposable Elements) is an R package for the exploration and identification of active transposons in RNA-seq data. The package offers functions to manipulate the RepeatMasker output files, and allows to discriminate TEs-coding transcripts from those repeats that are co-transcribed with genes coding non-transposon proteins. Through a simple pipeline you can solve overlaps of the repetitions that RepeatMasker cannot solve based on either higher score (HS), longer length (LE) or lower Kimura’s distances (LD). The transposons are finally annotated in the reference file using a selection criterion based on the percentage of identity, the percentage of the length of the repeat in accordance with the transcript, and a minimum length in base pairs (Wicker's rule or user's defined). In addition, a decoy file and a transcriptome salmon-formated are created to be used for indexing and quantification with Salmon. Finally, a function is incorporated to import the quantification estimates of the transcripts into the R environment for their subsequent differential expression analysis.

## INDEX
1.    [INSTALLING ExplorATE](#t1)
2.    [QUICK START](#t2)
3.    [MAKING INPUT FILES](#t3)
4.    [FILTERING COTRANSCRIBED REPEATS](#t4)
5.    [RESOLVING OVERLAPPING](#t5)
6.    [TRANSPOSONS ANNOTATION AND MAKING REFERENCE FILES](#t6)
7.    [SALMON QUANTIFICATION ESTIMATION](#t7)
8.    [IMPORT ESTIMATES TO R FOR DIFFERENTIAL EXPRESSION ANALYSIS](#t8)
9.    [BIBLIOGRAPHY](#t9)

## 1. INSTALLING ExplorATE {#t1}

ExplorATE requires some previously installed packages, select those packages that are not available in your environment:
```{r eval=FALSE}
#install complementary packages
install.packages(c("stringr","seqinr","foreach","doParallel"))
install.packages(c("BiocManager","devtools")) #BiocManager is required to install the packages below and devtools is required if you want to install from GitHub 

BiocManager::install(c("readr","GenomicRanges", "IRanges","csaw", "edgeR","SummarizedExperiment","DESeq2", "tximport"))
```

You can install ExplorATE locally by downloading the file `ExplorATE_0.1.tar.gz` or install via GitHub using `devtools::install_github()`   
```{r eval=FALSE}
#install ExplorATE locally
install.packages("./ExplorATE_0.1.tar.gz", repos=NULL, type = "source")

#install ExplorATE from GitHub
devtools::install_github("FemeniasM/ExplorATEproject")
```

## 2. QUICK START {#t2}

The analysis is summarized below in three simple steps, however we encourage the user to explore the extended pipeline step by step. First we need to create a reference file that contains the transposon class/superfamily for each transcript excluding those repeats that are co-transcribed with protein coding genes and resolving the overlaps between repeats. For this we can execute the following command:

```{r eval=FALSE}
RM.reference <- ExplorATE::mk.reference(RepMask = "RM.out",
                                       gff3 = "TransDecoder.gff3",
                                       anot = "BLAST.outfmt6",
                                       stranded = T,
                                       cleanTEsProt = F,
                                       featureSum = T,
                                       outdir = "./outdir",
                                       rm.cotrans = T,
                                       overlapping = T,
                                       align = "RM.aln",
                                       over.res = "LD",
                                       ignore.aln.pos = T,
                                       threads = 18,
                                       trme = "transcriptome.fa",
                                       by = "classRep",
                                       rule = c(90,80,100)
                                   )
```

When executing the `mk.reference` function, it will initially ask us if the assigned classes/superfamilies are correct. You should check that there are no ambiguities in the labeling.
After creating the reference file, the next step is to perform the quantification estimate with Salmon. Make sure to use the --gcBias, --validateMappings, --useVBOpt flags and the decoy.txt file generated by `mk.reference`. You will find the details in [Patro et al. (2017)](https://www.nature.com/articles/nmeth.4197), [Love et al. (2016)](https://www.nature.com/articles/nbt.3682) and [Srivastava et al. (2020)](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02151-8).

If you have any questions about how to run the program you can consult the documentation of [Salmon](https://salmon.readthedocs.io/en/latest/salmon.html#using-salmon). Linux users can use the `run.salmon` or run Salmon with the appropriate arguments:

```{r eval=FALSE}
ExplorATE::run.salmon(index = "sampleIndex",
                      decoys = "decoy.txt",
                      salmon_path = "path/to/salmon-latest_linux_x86_64/bin/salmon",
                      kmer = 31,
                      threads = 18,
                      trme = "path/to/trmeSalmon.fasta",
                      lib_dir = "path/to/reads",
                      pe_se = "pe"
                      )
```

Finally we import the estimates from Salmon and create a DGEList or DESeqDataSet object with the estimates corrected for changes in the average length of the transcripts across the samples.

```{r eval=FALSE}
y <- ExplorATE::import.RTEs(
  path.sal = "path/to/salmon/output",
  conditions = rep(c("S1", "S2", "S3"), each = 3),
  ref.sal = RM.reference,
  import_to = "edgeR"
)
```

The y object is ready to be used for differential expression analysis in edgeR. If you will use DESeq2 for later differential expression analysis, you must use the `import_to = "DESeq2"` argument. If the `import_to =` argument is omitted, the transcript-level estimates will be imported.


## 3. MAKING INPUT FILES {#t3}

Before using ExplorATE you must generate files containing detailed annotations of the repeats present in the transcriptome and the gene-encoding transcripts. Additionally you will want to generate some files that help refine the TEs annotation.

### 3.1 RepeatMasker repeats annotations {#t3.1}

To create a reference file, you must first enter a file containing detailed annotations of the repeats present in the transcriptome. For this you can screen your transcriptome against curated libraries like [Dfam](https://www.dfam.org/home) (HMM profiles derived from Repbase) or [Repbase](https://www.girinst.org/) using [RepeatMasker](http://www.repeatmasker.org/). You can also perform TE family identification and modeling with [RepeatModeler](http://www.repeatmasker.org/RepeatModeler/).
In all cases you should only retain the transposon class/families that may be present in your RNA-seq data such as retrotransposons.
We recommend that you generate the alignment file `.aln` together with the RepeatMasker output. This file can be used later in the resolution of overlapping repeats within the same transcript.

You can use the `read.RepMask()` function to read the RepeatMasker output file and verify it. The function `read.alignfile()` allows reading the alignment file and returns a `data.frame` with the identification of the sequence, the Family of the assigned repetition. You can average the distances per sequence or per family of TEs (you can run `?read.alignfile()` for more details).

Some examples are shown below:

```{r eval=FALSE}
RM <- ExplorATE::read.RepMask("RM.out")
ALN <- ExplorATE::read.alignfile("RM.aln", average = T, by="classRep")
```

#### 3.1.1 Avoid ambiguities in repeats annotations {#t3.1.1}

It is possible that if different libraries are consulted there will be differences in the labeling of some repetitions. These ambiguities will cause problems later in the workflow so we must eliminate them. When we execute the function `rm.cotransRep()` it will ask us if the names assigned to the repetitions are correct (see the section [4](#t4)). The example below shows how we can unify the names. Suppose your RepeatMasker file contains ambiguities for SINEs elements and you want to unify according to Repbase groups.

First we check the repeats names, for this you can run these simple commands:

```{r eval=FALSE}
RM <- ExplorATE::read.RepMask("RM.out")
sort(unique(RM$classRep))
```

If we find elements identified as `"NonLTR/SINE/7SL"` or `"NonLTR/SINE/tRNA"`, we can simply replace them with the correct assignment as follows:

```{r eval=FALSE}
RM$classRep <- gsub("NonLTR/SINE/7SL", "NonLTR/SINE/SINE1", RM$classRep)
RM$classRep <- gsub("NonLTR/SINE/tRNA", "NonLTR/SINE/SINE2", RM$classRep)
```

### 3.2 Protein-coding genes annotations {#t3.2}

You can enter a reference file in `.outfmt6` format that is obtained from the output of annotators such as BLAST or dammit!. You must remove all annotations that correspond to transposon proteins such as reverse transcriptases, endonucleases, transposases, tyrosine recombinases, etc. Only in exploratory analyses you can enter your `.outfmt6` file without removing proteins related to transposons and use a local database to remove them. In this case, the annotations must be in UniProt/Swiss-Prot ID format such as "CO1A2_MOUSE" or "sp|Q01149|CO1A2_MOUSE" or "tr|H9GLU4|H9GLU4_ANOCA". You can assign the annotations file to an object and explore it with basic R functions, for example:

```{r eval=FALSE}
GENE.ANOT <- read.outfmt6("BLAST.outfmt6")
head(GENE.ANOT)
```

When repeats are co-transcribed with coding genes, you may want to know where this repeat is. You can supply a `.gff` file with the features for each transcript. In this way you find a detailed output of the repeats found in 5'-UTR, 3'-UTR or CDS regions.
You can generate a `.gff` file with [TransDecoder](https://github.com/TransDecoder/TransDecoder/wiki). We recommend running it with BLASTP and Pfam searches, and retaining only the best ORF.
In the same way as the annotations file, the `.gff` file can be assigned an object and explored with the basic R functions:

```{r eval=FALSE}
GFF3 <- read.gff3("TransDecoder.gff3")
head(GFF3)
```


## 4. FILTERING COTRANSCRIBED REPEATS {#t4}

Many of the repeats that were annotated in our transcriptome did not truly correspond to transposons. Some repeats may be co-transcribed with genes, therefore the first step for correct transposon annotation is the removal of repeats associated with coding genes. The `rm.cotransRep()` function remove this repeats from our RepeatMasker file.

```{r eval=FALSE}
RM.cotransClean <- ExplorATE::rm.cotransRep(RepMask = "RM.out",
                                       gff3 = "TransDecoder.gff3",
                                       anot = "BLAST.outfmt6",
                                       stranded = T,
                                       cleanTEsProt = F,
                                       featureSum = T,
                                       outdir = "./outdir")
```

In the above function you can assign both the input files' path and the assigned objects within the R environment. Therefore if you made modifications of these files within the R environment, you can assign them as follows:

```{r eval=FALSE}
RM <- ExplorATE::read.RepMask("RM.out")
GENE.ANOT <- read.outfmt6("BLAST.outfmt6")
GFF3 <- read.gff3("TransDecoder.gff3")

RM$classRep <- gsub("NonLTR/SINE/7SL", "NonLTR/SINE/SINE1", RM$classRep)
RM$classRep <- gsub("NonLTR/SINE/tRNA", "NonLTR/SINE/SINE2", RM$classRep)

RM.cotransClean <- ExplorATE::rm.cotransRep(RepMask = RM,
                                       gff3 = GFF3,
                                       anot = GENE.ANOT,
                                       stranded = T,
                                       cleanTEsProt = F,
                                       featureSum = T,
                                       outdir = "./outdir")

```

The argument `cleanTEsProt` refers to whether the annotations file `.outfmt6` contains TEs-related proteins. We suggest that the file does not contain such proteins that the user should carefully remove from the annotations file, and by default this argument is `cleanTEsProt = FALSE` (see section [3.2](#t3.2)).

If the argument `featureSum = T` two additional files are created (in addition to the RepeatMasker file without co-transcribed repeats). A file containing a summary of the protein-coding transcripts carrying repeats and a barplot summarizing the number of repeats in each 3'-UTR, 5'-UTR and CDS regions for each TEs class/family.

## 5. RESOLVING OVERLAPPING {#t5}

The RepeatMasker output file may contain overlapping repetitions when the program cannot resolve them automatically. You can resolve these overlaps with the python [script](https://github.com/rmhubley/RepeatMasker/blob/master/util/RM2Bed.py) provided by the creators of the program, or you can work it within the R environment with the function `ovlp.res()` Like the python script, the `ovlp.res()` function allows to solve the overlaps considering the higher score ("HS"), a longer length ("LE") or lower Kimura's distances ("LD"), that are assigned with the argument `over.res =`.  When two repeats partially overlap, the overlapping bases are assigned to the item with the best score. If one repeat is contained within another, the repeat with the lowest score is discarded. If two items have the same score, they are assigned based on the first item in the RepeatMasker file.

```{r eval=FALSE}
RM.ovlp.res <- ExplorATE::ovlp.res(RepMask = "RM.out",
                                       gff3 = "TransDecoder.gff3",
                                       anot = "BLAST.outfmt6",
                                       stranded = T,
                                       cleanTEsProt = F,
                                       featureSum = T,
                                       outdir = "./outdir",
                                       rm.cotrans = T,
                                       ignore.aln.pos = T,
                                       threads = 18,
                                       align = "RM.aln",
                                       over.res = "LD",
                                   )
```

You can enter a raw RepeatMasker file, in this case if you want to remove co-transcribed repeats you must select the `rm.cotrans = T` argument. As mentioned in the previous section, we recommend that you perform the removal of proteins associated with transposable elements in the `.outfmt6` file and therefore you should assign `cleanTEsProt = F`. Alternatively you can enter with the argument `RepMask =` a preprocessed RepeatMasker file in which the removal of co-transcribed repetitions has already been performed:

```{r eval=FALSE}
RM.ovlp.res <- ExplorATE::ovlp.res(RepMask = RM.cotransClean,
                                    align = "RM.aln",
                                    over.res = "LD",
                                    ignore.aln.pos = T,
                                    threads = 18,
                                  )
```

Notice that the output directory `outdir =` is only required if `featureSum = T` and the alignments file `align =` is only required if "low divergence" is used as the resolution parameter (`over.res = "LD"`).

When the resolution of overlaps is done by "low divergence" (LD), the `ignore.aln.pos` argument must be added. Since there may be discrepancies in the positions between the alignment file and RepeatMasker output file, you can select whether or not to take them into account. If `ignore.aln.pos = T` the positions are ignored and the mean of class/family of repeats per transcript is taken.

The `ovlp.res()` function allows parallel processing. Select the number of cores to use with the `threads =` argument.

## 6. TRANSPOSONS ANNOTATION AND MAKING REFERENCE FILES {#t6}

After cleaning our RepeatMasker file of cotranscript repeats and resolving overlaps, we annotated transcripts that potentially correspond to TEs using a selection criteria. These annotated transposons are used to generate a reference file and all remaining transcripts will be used as decoys in the estimation of subsequent quantification. To create these files directly you can use the `mk.reference ()` function. By default, the rule 80-80-08 of [Wicker et al. (2007)] (https://www.nature.com/articles/nrg2165) is used; that is only those transcripts that have 80% identity in 80% of the transcript and at least 80 bp in length will be annoted as TEs. However you can modify these values with the `rule =` argument. Like the above functions you can supply a clean RepeatMasker file or a raw RepeatMasker file and assign the appropriate arguments to perform the cleaning as shown in the examples below:

```{r eval=FALSE}
RM.reference <- ExplorATE::mk.reference(RepMask = "RM.out",
                                       gff3 = "TransDecoder.gff3",
                                       anot = "BLAST.outfmt6",
                                       stranded = T,
                                       cleanTEsProt = F,
                                       featureSum = T,
                                       outdir = "./outdir",
                                       rm.cotrans = T,
                                       overlapping = T,
                                       align = "RM.aln",
                                       over.res = "LD",
                                       trme = "transcriptome.fa",
                                       ignore.aln.pos = T,
                                       threads = 18,
                                       by = "classRep",
                                       rule = c(90,80,100)
                                   )
```

In this example the argument `overlapping = T` indicates that our input file still needs to resolve the overlaps. Furthermore, the argument `rule = c (90,80,100)` indicates that transcripts that have 90% identity in 80% (or more) of the transcript with more than 100bp in length will be annotated. The `by =` argument indicates whether the classification should be done at the class, superfamily or family level (not recommended for exploratory analysis without reference genome). If you select `by = "classRep"` the column "classRep" from the RepeatMasker file will be used.

If you start from a processed file, *i.e.* without co-transcribed repeats or overlaps, you could run a code like the following:

```{r eval=FALSE}
RM.reference <- ExplorATE::mk.reference(RepMask = RM.ovlp.res,
                                       outdir = "./outdir",
                                       trme = "transcriptome.fa",
                                       by = "classRep",
                                       rule = c(90,80,100)
                                   )
```

The `mk.reference()` function returns a `data.frame` with annotated TEs transcripts and creates three files in the output directory: a `reference.csv` file with the annotations, a `decoy.txt` file and a `trmeSalmon.fasta` that will be used in quantification with Salmon.

## 7. SALMON QUANTIFICATION ESTIMATION {#t7}

The [Salmon](https://combine-lab.github.io/salmon/getting_started/) program is widely used in the transcripts quantification because it is very fast and accurate. You can run Salmon locally or, if you are a Linux user, you can run it through the `run.salmon` function. If you have questions about how to run the program locally, please see the detailed Salmon's [documentation](https://salmon.readthedocs.io/en/latest/). You must make sure to use the --gcBias and --validateMappings flags and the `decoy.txt` file generated by the `mk.reference ()` function. Details of these arguments can be found in [Patro et al. (2017)](https://www.nature.com/articles/nmeth.4197), [Love et al. (2016)](https://www.nature.com/articles/nbt.3682) and [Srivastava et al. (2020)](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02151-8).   

Linux users can run Salmon with the `run.salmon` function, however it requires that the program be already installed on their computer. An example to execute the function is shown below:

```{r eval=FALSE}
ExplorATE::run.salmon(index = "sampleIndex",
                      decoys = "decoy.txt",
                      salmon_path = "path/to/salmon-latest_linux_x86_64/bin/salmon",
                      kmer = 31,
                      threads = 18,
                      trme = "path/to/trmeSalmon.fasta",
                      lib_dir = "path/to/reads",
                      pe_se = "pe"
                      )
```

## 8. IMPORT ESTIMATES TO R FOR DIFFERENTIAL EXPRESSION ANALYSIS {#t8}

The last step is to import the quantification estimates into the R environment and create a DGEList or DESeqDataSet object to perform the subsequent differential expression analysis. The `import.RTEs()` function imports the estimates using the `tximport` package (see [Soneson et al. (2015)] (https://f1000research.com/articles/4-1521/v1) for more details). The  `import.RTEs()` function directly creates an offset that corrects the estimates for changes in the average transcripts length across samples. The following code shows an example to create a DGEList object:
and, additionally, an array of CPMs is added to the object
```{r eval=FALSE}
y <- ExplorATE::import.RTEs(
  path.sal = "path/to/salmon/output",
  conditions = rep(c("S1", "S2", "S3"), each = 3),
  ref.sal = RM.reference,
  import_to = "edgeR"
)
```

In the example above, the argument `import_to = "edgeR"` was selected to create a DGEList object. Additionally this function will add a CPMs matrix to the DGEList object. Now you can continue with the dispersion estimation functions in edgeR. For more details, see the [edgeRUserGuide](https://bioc.ism.ac.jp/packages/2.11/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf). More details of the edgeR package can be found in [Robinson et al. (2010)](https://academic.oup.com/bioinformatics/article/26/1/139/182458). 

Alternatively, you can select `import_to = "DESeq2"` and continue with the `DESeq ()` function (see [DESeq2 vignette](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) and [Love et al. (2014)](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8) for more details). If neither option is selected, the transcript-level estimates will be imported.

## 9. BIBLIOGRAPHY {#t9}

Haas, B., Papanicolaou, A., Yassour, M. et al. De novo transcript sequence reconstruction from RNA-seq using the Trinity platform for reference generation and analysis. Nat Protoc 8, 1494–1512 (2013). https://doi.org/10.1038/nprot.2013.084

Love, M. I., Huber, W. & Anders, S. Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biol 15, 550 (2014). https://doi.org/10.1186/s13059-014-0550-8

Love, M. I., Hogenesch, J. & Irizarry, R. Modeling of RNA-seq fragment sequence bias reduces systematic errors in transcript abundance estimation. Nat Biotechnol 34, 1287–1291 (2016). https://doi.org/10.1038/nbt.3682

Patro, R., Duggal, G., Love, M. I. et al. Salmon provides fast and bias-aware quantification of transcript expression. Nat Methods 14, 417-419 (2017). https://doi.org/10.1038/nmeth.4197

Robinson M. D., McCarthy D. J. , Smyth G. K. edgeR: a Bioconductor package for differential expression analysis of digital gene expression data. Bioinformatics 26(1), 139–140 (2010). https://doi.org/10.1093/bioinformatics/btp616

Smit, A., Hubley, R & Green, P. RepeatMasker Open-4.0, (2013-2015). http://www.repeatmasker.org

Soneson C., Love M. I. and Robinson M. D. Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences. F1000Research 4(1521), (2015). https://doi.org/10.12688/f1000research.7563.1

Srivastava, A., Malik, L., Sarkar, H. et al. Alignment and mapping methodology influence transcript abundance estimation. Genome Biol 21, 239 (2020). https://doi.org/10.1186/s13059-020-02151-8

The UniProt Consortium. UniProt: a worldwide hub of protein knowledge, Nucleic Acids Research 47(D1), D506–D515 (2019). https://doi.org/10.1093/nar/gky1049

Wicker, T., Sabot, F., Hua-Van, A. et al. A unified classification system for eukaryotic transposable elements. Nat Rev Genet 8, 973–982 (2007). https://doi.org/10.1038/nrg2165


